{
  "id": "54051207-0deb-4713-a060-63c0e1e92a04",
  "name": "LeetCode Patterns",
  "description": "",
  "cards": [
    {
      "id": "3a45428d-a93a-474a-82a7-6bd89d1871e3",
      "front": "How does Prefix Sum work?",
      "back": "**Core Concept:** Pre-compute cumulative sums to answer range sum queries in O(1) time.\n\n**Mechanism:** \n- Build an array where `prefix[i] = sum of elements from index 0 to i`\n- Range sum from i to j = `prefix[j] - prefix[i-1]`\n\n**When to Use:** Subarray sum problems, range queries, finding subarrays with specific sums\n\n**Key Steps:** \n1. Create prefix sum array\n2. Use formula: sum(i,j) = prefix[j] - prefix[i-1]\n3. Handle edge cases (i=0)",
      "created": "2025-08-25T18:49:02.102073459-06:00",
      "modified": "2025-08-25T18:49:02.102073459-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:49:02.102073459-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "bc08aed3-4e05-4ef6-a45b-9742ea534a1b",
      "front": "How does Two Pointer work?",
      "back": "**Core Concept:** Use two pointers moving toward each other or in same direction to solve problems in O(n) time instead of O(n²).\n\n**Mechanism:**\n- **Opposite direction:** Start at beginning/end, move toward center\n- **Same direction:** Both start at beginning, move at different speeds\n\n**When to Use:** Sorted arrays, palindromes, pair problems, removing duplicates\n\n**Key Steps:**\n1. Initialize pointers at appropriate positions\n2. Move pointers based on comparison/condition\n3. Continue until pointers meet or cross",
      "created": "2025-08-25T18:52:17.14935576-06:00",
      "modified": "2025-08-25T18:52:17.14935576-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:52:17.14935576-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "e949d910-675f-4493-9db0-b9bdaf8f011b",
      "front": "How does Sliding Window work?",
      "back": "**Core Concept:** Maintain a window of elements and slide it across array/string to find optimal subarray/substring.\n\n**Types:**\n- **Fixed size:** Window size stays constant\n- **Variable size:** Window grows/shrinks based on conditions\n\n**When to Use:** Subarray/substring problems with size constraints or conditions\n\n**Key Steps:**\n1. Expand window by moving right pointer\n2. Contract window by moving left pointer when condition violated\n3. Update answer when valid window found\n4. Use hashmap/counter for character/element tracking",
      "created": "2025-08-25T18:52:47.420203379-06:00",
      "modified": "2025-08-25T18:52:47.420203379-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:52:47.420203379-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "b15c9ea1-e0cf-44ac-8067-2a1c2ac7ebd8",
      "front": "How does Fast \u0026 Slow Pointers work?",
      "back": "**Core Concept:** Two pointers moving at different speeds to detect cycles or find middle elements.\n\n**Mechanism:**\n- Slow pointer moves 1 step\n- Fast pointer moves 2 steps\n- If there's a cycle, they'll eventually meet\n\n**When to Use:** Cycle detection in linked lists, finding middle of linked list, happy number problems\n\n**Key Steps:**\n1. Initialize slow and fast pointers at head\n2. Move slow by 1, fast by 2\n3. Check if they meet (cycle exists) or fast reaches null (no cycle)\n4. For middle element: when fast reaches end, slow is at middle",
      "created": "2025-08-25T18:53:17.770259081-06:00",
      "modified": "2025-08-25T18:53:17.770259081-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:53:17.770259081-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "99ecf3d3-f8a5-42cd-a225-f5b2d1c3b5f0",
      "front": "How does LinkedList In-place Reversal work?",
      "back": "**Core Concept:** Reverse links between nodes without using extra space by manipulating pointers.\n\n**Mechanism:**\n- Keep track of previous, current, and next nodes\n- Reverse the link direction iteratively\n\n**When to Use:** Reversing linked list, reversing sublists, palindrome checking\n\n**Key Steps:**\n1. Initialize: prev=null, curr=head\n2. For each node:\n   - Store next = curr.next\n   - Reverse link: curr.next = prev\n   - Move forward: prev=curr, curr=next\n3. Return prev (new head)",
      "created": "2025-08-25T18:53:43.294559216-06:00",
      "modified": "2025-08-25T18:53:43.294559216-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:53:43.294559216-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "abfea1b5-7a26-44f7-9deb-388dd5b7a87c",
      "front": "How does Monotonic Stack work?",
      "back": "**Core Concept:** Maintain a stack where elements are in increasing or decreasing order to solve \"next greater/smaller element\" problems.\n\n**Types:**\n- **Increasing stack:** Remove smaller elements when larger element comes\n- **Decreasing stack:** Remove larger elements when smaller element comes\n\n**When to Use:** Next greater element, largest rectangle, temperature problems\n\n**Key Steps:**\n1. Iterate through array\n2. Pop elements from stack that violate monotonic property\n3. Process popped elements (they found their answer)\n4. Push current element to stack",
      "created": "2025-08-25T18:54:10.809454259-06:00",
      "modified": "2025-08-25T18:54:10.809454259-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:54:10.809454259-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "6823e8db-d3ce-4183-ab5e-1607d0603e81",
      "front": "How does Top-K Elements work?",
      "back": "**Core Concept:** Use heap (priority queue) or quickselect to efficiently find K largest/smallest elements.\n\n**Approaches:**\n- **Min heap of size K:** For K largest elements\n- **Max heap of size K:** For K smallest elements\n- **Quickselect:** For Kth element specifically\n\n**When to Use:** Kth largest/smallest, top K frequent elements, closest points\n\n**Key Steps:**\n1. Use appropriate heap type\n2. Maintain heap of size K\n3. For elements beyond K, compare with heap top\n4. Replace if necessary to maintain top K",
      "created": "2025-08-25T18:54:34.533944341-06:00",
      "modified": "2025-08-25T18:54:34.533944341-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:54:34.533944341-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "ae3148da-7bd4-4666-ba93-96ffaebf2be2",
      "front": "How does Overlapping Intervals work?",
      "back": "**Core Concept:** Sort intervals by start time, then merge or process overlapping ones.\n\n**Key Insight:** Two intervals [a,b] and [c,d] overlap if a ≤ d and c ≤ b\n\n**When to Use:** Merging intervals, scheduling conflicts, range problems\n\n**Key Steps:**\n1. Sort intervals by start time\n2. Iterate through sorted intervals\n3. Check if current overlaps with previous\n4. Merge if overlapping, otherwise add to result\n5. Update end time to maximum of overlapping intervals",
      "created": "2025-08-25T18:55:00.243366564-06:00",
      "modified": "2025-08-25T18:55:00.243366564-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:55:00.243366564-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "a30bd06f-d94e-4caf-a9af-28a5b6382174",
      "front": "How does Modified Binary Search work?",
      "back": "**Core Concept:** Adapt binary search for rotated arrays, infinite arrays, or finding insertion points.\n\n**Variations:**\n- **Rotated sorted array:** Determine which half is sorted\n- **Find target range:** Find first and last occurrence\n- **Search in infinite array:** First find bounds, then binary search\n\n**When to Use:** Rotated arrays, finding boundaries, peak elements\n\n**Key Steps:**\n1. Identify the modification needed\n2. Maintain low, high pointers\n3. Calculate mid and determine which half to search\n4. Adjust condition for comparison\n5. Handle edge cases specific to variant",
      "created": "2025-08-25T18:55:29.505788686-06:00",
      "modified": "2025-08-25T18:55:29.505788686-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:55:29.505788686-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "7480435f-d72e-4e06-80db-666d24733ae0",
      "front": "How does Binary Tree Traversal work?",
      "back": "**Core Concept:** Visit all nodes in tree following specific order patterns.\n\n**Types:**\n- **Preorder:** Root → Left → Right\n- **Inorder:** Left → Root → Right (gives sorted order for BST)\n- **Postorder:** Left → Right → Root\n- **Level-order:** BFS, level by level\n\n**When to Use:** Tree serialization, expression trees, finding paths\n\n**Implementation:**\n- **Recursive:** Natural and clean\n- **Iterative:** Use stack (DFS) or queue (BFS)",
      "created": "2025-08-25T18:56:16.762091685-06:00",
      "modified": "2025-08-25T18:56:16.762091685-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:56:16.762091685-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "e2b25456-6aa3-4ccc-aa4c-2df8bf922447",
      "front": "How does Depth-First Search (DFS) work?",
      "back": "**Core Concept:** Explore as deep as possible along each branch before backtracking.\n\n**Implementation:**\n- **Recursive:** Use call stack implicitly\n- **Iterative:** Use explicit stack\n\n**When to Use:** Path finding, connected components, topological sort, cycle detection\n\n**Key Steps:**\n1. Mark current node as visited\n2. Process current node\n3. Recursively visit all unvisited neighbors\n4. Backtrack when no more unvisited neighbors",
      "created": "2025-08-25T18:56:48.220321926-06:00",
      "modified": "2025-08-25T18:56:48.220321926-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:56:48.220321926-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "7c9e2abf-03fd-458a-9078-35c7cf60a0ee",
      "front": "How does Breadth-First Search (BFS) work?",
      "back": "**Core Concept:** Explore all neighbors at current depth before moving to next depth level.\n\n**Implementation:** Always use queue (FIFO)\n\n**When to Use:** Shortest path in unweighted graph, level-order traversal, minimum steps problems\n\n**Key Steps:**\n1. Add starting node to queue\n2. While queue not empty:\n   - Dequeue a node\n   - Process it\n   - Add all unvisited neighbors to queue\n   - Mark neighbors as visited",
      "created": "2025-08-25T18:57:23.429707043-06:00",
      "modified": "2025-08-25T18:57:23.429707043-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:57:23.429707043-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "e9eeacf9-30b6-4879-84f7-15467761293c",
      "front": "How does Matrix Traversal work?",
      "back": "**Core Concept:** Navigate through 2D grid using various patterns while handling boundaries.\n\n**Common Patterns:**\n- **4-directional:** Up, down, left, right\n- **8-directional:** Include diagonals\n- **Spiral:** Traverse in spiral pattern\n- **Diagonal:** Traverse diagonally\n\n**When to Use:** Island problems, path finding in grid, word search, spiral traversal\n\n**Key Steps:**\n1. Check boundaries (row/col limits)\n2. Mark visited cells\n3. Use direction arrays for clean movement\n4. Apply DFS/BFS as needed",
      "created": "2025-08-25T18:57:45.435135246-06:00",
      "modified": "2025-08-25T18:57:45.435135246-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:57:45.435135246-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "da8f3494-7836-43fc-b55d-cd9ec34d795f",
      "front": "How does Backtracking work?",
      "back": "**Core Concept:** Try all possible solutions by making choices, and undo them if they don't lead to solution.\n\n**Pattern:**\n1. **Choose:** Make a choice\n2. **Explore:** Recursively explore with that choice\n3. **Unchoose:** Backtrack (undo the choice)\n\n**When to Use:** Generating permutations/combinations, N-Queens, sudoku solver, word search\n\n**Key Steps:**\n1. Base case: valid solution found or impossible\n2. Try each possible choice\n3. Recursively solve with that choice\n4. Backtrack: undo choice before trying next\n5. Use visited/used tracking",
      "created": "2025-08-25T18:58:05.432007211-06:00",
      "modified": "2025-08-25T18:58:05.432007211-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:58:05.432007211-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    },
    {
      "id": "f457e8b5-5e55-4ecb-978b-d04b3c9a7593",
      "front": "How does Dynamic Programming work?",
      "back": "**Core Concept:** Break down complex problems into simpler subproblems and store results to avoid recomputation.\n\n**Approaches:**\n- **Top-down (Memoization):** Recursion + caching\n- **Bottom-up (Tabulation):** Build solution iteratively\n\n**When to Use:** Overlapping subproblems + optimal substructure (Fibonacci, knapsack, longest subsequence)\n\n**Key Steps:**\n1. Identify overlapping subproblems\n2. Define state (DP array meaning)\n3. Find recurrence relation\n4. Handle base cases\n5. Build solution bottom-up or memoize top-down\n\n**Common Patterns:** Linear DP, 2D grid DP, interval DP, tree DP",
      "created": "2025-08-25T18:58:34.290721828-06:00",
      "modified": "2025-08-25T18:58:34.290721828-06:00",
      "interval": 1,
      "repetition": 0,
      "ease_factor": 2.5,
      "next_review": "2025-08-25T18:58:34.290721828-06:00",
      "last_review": "0001-01-01T00:00:00Z"
    }
  ],
  "created": "2025-08-25T18:26:13.858837667-06:00",
  "modified": "2025-08-25T18:58:34.290725334-06:00"
}